# Sorting small arrays, less than 32 elements
# Follows quadsort: https://github.com/scandum/quadsort

# The general strategy is to sort an initial portion (at least half the
# array) with a power-of-two length using merge sort, then add the rest
# of the elements with insertion sort.
# These methods are mostly branchless, with some shortcuts that make
# them adapt slightly to already-sorted data

# Sort exactly 2 elements branchlessly
def sort_2{dst, src} = {
  c := src >* src+1
  t := src->(~c)
  dst <-{0} src->c
  dst <-{1} t
  c
}
def sort_2{ptr} = sort_2{ptr, ptr}

# 0 to 3 elements, could be considered a bubble sort or insertion sort
def sort_lt4{dst, src, n} = {
  def mov = ~match{dst,src}
  if (n > 1) {
    sort_2{dst, src}
    if (n > 2) {
      if (mov) dst <-{2} src->2
      sort_2{dst+1}
      sort_2{dst}
    }
  } else if (mov and n == 1) {
    dst <- *src
  }
}

# The adaptive quad swap
def sort_4_quad{dst, src} = {
  def s22{dst, src} = @for_const (i to 2) sort_2{dst+2*i, src+2*i}
  s22{dst, src}
  if (sort_2{dst+1}) {
    s22{dst, dst}
    sort_2{dst+1}
  }
}

# Specialized parity merging for 8 or 16 elements
# Always use 2 rounds of merges to get from ptr to swap and back
def sort_8_16_parity{n, sort_q, merge_h}{dst, src} = {
  def T = scaltype{dst}
  # n elements of swap space
  def sw{p:pT} = {s:type{p} = copy{n,0}}
  extend perv1{sw}
  def swap = sw{dst}

  # Sort groups of 2 or 4 elements
  def q = n/4
  @for_const (i to 4) sort_q{dst + q*i, src + q*i}

  # Check to see if these groups need to be merged at all
  def chk{i} = dst+(i*q - 1) >* dst+(i*q)
  if (chk{1} or chk{2} or chk{3}) {
    # Two rounds of merging: dst to swap in two parts, then back
    def h = n/2
    @for_const (i to 2) parity_merge_const{h, swap + h*i, dst + h*i}
    merge_h{dst, swap}
  }
}
def sort_8_parity = sort_8_16_parity{
  8, sort_2,
  {d,s}=>parity_merge_const{8, d, s}
}
def sort_16_parity = sort_8_16_parity{
  16, sort_4_quad,
  {d,s}=>parity_merge{eltype{type{d}}}(d, s, 8, 16)
}

local include 'util/perv'
def sort_lt32{dst, src, n:U, max} = {
  def use{l, sort} = {
    sort{dst, src}
    def cpy{dst,src} = {
      if (isid{src} or dst!=src) @for (dst,src over _ from l to n) dst=src
    }
    extend perv2{cpy}
    cpy{dst, src}
    insertion_finish{dst, dst, l, n}
  }
  if      (max <=  4 or n <  4) sort_lt4{dst, src, n}
  else if (max <=  8 or n <  8) use{ 4, sort_4_quad}
  else if (max <= 16 or n < 16) use{ 8, sort_8_parity}
  else                          use{16, sort_16_parity}
}
def sort_lt32{dst, src, n:U} = sort_lt32{dst, src, n, 32}
def sort_lt32{ptr, n:U, max & knum{max}} = sort_lt32{ptr, ptr, n, max}
def sort_lt32{ptr, n:U} = sort_lt32{ptr, ptr, n}
