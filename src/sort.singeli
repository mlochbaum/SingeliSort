include './base'
include './common'
include './ins'
include './merge'
include './count'
include './radix'
include './rh'
include './small'
include './quicksort'

# For 1-byte inputs, counting sort is usually best
sort8{U,T}(x:*T, n:U, aux:*void) : void = {
  if (n < 16) {
    sort_lt32{x, n}
  } else if (radix_fits{n,u8}) {
    radix_inplace{x, n, *T~~aux, *u8~~(aux+n)}
  } else {
    count_sort{x, n, aux}
  }
}

# For 2-byte inputs, use insertion, radix, or counting sort
sort16{U,T}(x:*T, n:U, aux:*void) : void = {
  if (n < 24) {
    sort_lt32{x, n}
  } else if (n < 1<<15) {
    radix{U,T}(x, n, aux)
  } else {
    count_sort{x, n, aux}
  }
}

'sort8'  = sort8 {usize, i8}
'sort16' = sort16{usize, i16}

'rhsort' = rh_sort{usize, i32, merge_chk, merge_from{merge_chk}, findrange}

flux32(x:*i32, n:u64, aux:*void) : void = {
  flux32loop(x, x, *i32~~aux, n)
}
'flux32' = flux32
