# Merge sorting

# Merge arrays of length l and n-l starting at a, using buffer aux.
# Branchy and slow
def branch_merge{a:pT, l:U, n:U, aux:pT} = {
  set{aux, a, l}
  ai:U=0; bi:U=l; i:U=0
  while (i < bi) {
    def pick{arr,ind} = { a <-{i} arr->ind; ++ind }
    if (bi >= n or aux->ai <= a->bi) {
      pick{aux,ai}
    } else {
      pick{a  ,bi}
    }
    ++i
  }
}

local {
  def extend ecmp{f} = {
    def f{a,b & ktup{a} & ktup{b}} = f{tupsel{0,a},tupsel{0,b}}
  }
  extend ecmp{__le}; extend ecmp{__gt}
}

# Parity merge: branchless
# Main data movement
def parity_pos{left, right, dst} = {
  l := left->0; r := right->0
  c := l <= r; d := ~c
  dst <-{c} r; right += d
  dst <-{d} l; left  += c
  ++dst
}
def parity_neg{left, right, dst} = {
  l := left->0; r := right->0
  c := l <= r; d := ~c
  --dst
  dst <-{c} r; right -= c
  dst <-{d} l; left  -= d
}
def sel{cmp, a, b} = { r := b; if (cmp{single{a},single{b}}) r = a; r }

# Merge halves of length-n array with constant n (4 and 8 used)
def parity_merge_const{n, dst, src} = {
  def h = n / 2
  left := clone{src}; right := src + h; dstc := clone{dst}
  @for_const (h-1) parity_pos{left, right, dstc}
  dstc <- sel{<=, left->0, right->0}

  left = src + (h-1); right = src + (n-1); dstc = dst + (n-1)
  @for_const (h-1) parity_neg{left, right, dstc}
  dstc <- sel{ >, left->0, right->0}
}

# Merge halves of array
parity_merge{T}(dst:*T, src:*T, half:usize, n:usize) : void = {
  lpos := src           ; rpos := src + half ; dpos := dst
  lneg := src + half - 1; rneg := src + n - 1; dneg := dst + n - 1

  @for (half-1) {
    parity_pos{lpos, rpos, dpos}
    parity_neg{lneg, rneg, dneg}
  }
  dpos <- sel{<=, *lpos, *rpos}
  dneg <- sel{ >, *lneg, *rneg}
}

# Check for easy cases when the merge can be avoided
# If the buffer helping at all, most merges go through these
def merge_chk{a:pT, l:U, n:U, aux:pT} = {
  if (a->(l-1) <= a->l) {
    0
  } else if (a->(n-1) < a->0 and l+l==n) {
    b := a+l;
    map{<->, a, b, l}
  } else {
    branch_merge{a,l,n,aux}
  }
}

# Merge array x of size n, if units of length block are pre-sorted
def merge_from{merge}{x:pT, n:U, aux:pT, block} = {
  w:U = block; while (w < n) {
    ww:=2*w
    i:U=0; while (i < n-w) {
      l := n-i; if (l>ww) l=ww
      merge{x+i, w, l, aux}
      i += ww
    }
    w = ww
  }
}
