# Merge arrays of length l and n-l starting at a, using buffer aux.
# Branchy and slow
def merge{a:pT, l:U, n:U, aux:pT} = {
  @for (a, aux over _ to l) aux=a
  ai:U=0; bi:U=l; i:U=0
  while (i < bi) {
    def pick{arr,ind} = { a <-{i} arr->ind; ++ind }
    if (bi >= n or aux->ai <= a->bi) {
      pick{aux,ai}
    } else {
      pick{a  ,bi}
    }
    ++i
  }
}

def swap{a, b} = { t:=a; a=b; b=t }

# Check for easy cases when the merge can be avoided
# If the buffer helping at all, most merges go through these
def merge_chk{a:pT, l:U, n:U, aux:pT} = {
  if (a->(l-1) <= a->l) {
    0
  } else if (a->(n-1) < a->0 and l+l==n) {
    b := a+l;
    @for (a, b over i to l) swap{a, b}
  } else {
    merge{a,l,n,aux}
  }
}

# Merge array x of size n, if units of length block are pre-sorted
def merge_from{merge}{x:pT, n:U, aux:pT, block} = {
  w:U = block; while (w < n) {
    ww:=2*w
    i:U=0; while (i < n-w) {
      l := n-i; if (l>ww) l=ww
      merge{x+i, w, l, aux}
      i += ww
    }
    w = ww
  }
}
