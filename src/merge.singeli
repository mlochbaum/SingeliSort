# Merge sorting

# Parity merge: branchless
# Main data movement
def parity_pos{dn, left, right, dst, i} = {
  l := left->0; r := right->i
  c := l <={dn} r
  if (c) r=l; dst <-{i} r
  right -= c
  left  += c
}
def parity_neg{dn, left, right, dst, i} = {
  l := left->(-i); r := right->0
  c := l <={dn} r
  if (c) l=r; dst <-{-i} l
  right -= c
  left  += c
}

# Merge halves of length-n array with constant n (4 and 8 used)
def parity_merge_const{dn, n, dst, src} = {
  def h = n / 2
  left := src; right := src + h; dstc := dst
  @for_const (i to h) parity_pos{dn, left, right, dstc, i}

  left = src + (h-1); right = src + (n-1); dstc = dst + (n-1)
  @for_const (i to h) parity_neg{dn, left, right, dstc, i}
}

# Branchless merge, combining lengths left and n-left from src to dst
# Not in-place: dst can't overlap src
# With guard==0, must have left*2 == n
# With guard==1,           left == n/2 (n can be odd)
# With guard==2, any lengths handled
def parity_merge_any{dn, T} = parity_merge{dn, T, 2}
parity_merge{dn, T, guard}(dst:*+T, src:*+T, left:U, n:U) : void = {
  parity_merge{dn, guard, dst, src, left, n}
}
def parity_merge_fn{dn, guard, dst, src, left, n} = {
  parity_merge{dn, eachrec{scaltype,dst}, guard}(dst, src, left, n)
}
def parity_merge{dn, guard, dst, src, left:U, n:U} = {
  def handle_any = guard >= 2
  def handle_odd = guard >= 1

  right := n - left
  lpos := src     ; rpos := src + left  ; dpos := dst
  lneg := rpos - 1; rneg := lneg + right; dneg := dst + n - 1

  half := left
  if (handle_any) {
    half = n/2
    parity_cuts{dn, n,dneg,dpos, half, tup{left,lneg,lpos}, tup{right,rneg,rpos}}
  }

  @for_unroll{2} (i to half) {
    parity_pos{dn, lpos, rpos, dpos, i}
    parity_neg{dn, lneg, rneg, dneg, i}
  }
  if (handle_odd and n%2) {
    l := lpos->0; r := rpos->half
    if (lpos > lneg-half) l = r
    dpos <-{half} l
  }
}

def parity_cuts{dn, n,dneg,dpos, half, ldata, rdata} = {
  # Suppose there are k "inside" elements on the long side that will
  # merge before the last one on the left
  # Then it's safe to perform short+k merges in that direction: only
  # the last can finish the short side, so nothing reads past it
  # To satisfy n/2 <= short+k, we have n <= 2*(short+k) + 1
  # That is, we can safely merge 2*k + short + 1 from the long side
  # So r->i < ll clears us to merge up to index 2*(i+1) + short
  # On the other hand, if r->i >= ll, it's safe to cut off i and past
  # The next index we check should be short + 2*i + 3
  def cut_sides{short,shneg,shpos, long,loneg,lopos, cmp} = {
    def cut{outside, do_cut} = {
      if (RARE{outside{e}}) {
        i := short
        while (i < e and not outside{i}) {
          i = 2*i + short + 3
          if (i >= e) i = e
        }
        do_cut{long - i}; long = i
        n = short + long
        half = n/2
        e = half - short - 1
      }
    }
    def setneg{len} = { loneg-=len; dneg-=len; set{dneg+1, loneg+1, len} }
    def setpos{len} = { set{dpos, lopos, len}; lopos+=len; dpos+=len }
    e := half - short - 1
    n0 := n
    do {
      n0 = n
      cut{bind{{v,i}=>{ cmp{v, lopos->i   }}, *shneg}, setneg}
      cut{bind{{v,i}=>{~cmp{v, loneg->(-i)}}, *shpos}, setpos}
    } while (n != n0)
  }
  if      (tupsel{0,ldata} < half) cut_sides{...ldata, ...rdata, <={dn}}
  else if (tupsel{0,rdata} < half) cut_sides{...rdata, ...ldata, < {dn}}
}

# Merge arrays of length l and n-l starting at a, using buffer aux
# Can be done without moving both sides, but this way's easy
def merge_pair{dn, x:pT, left:U, n:U, aux:pT} = {
  set{aux, x, n}
  parity_merge_any{dn, eltype{pT}}(x, aux, left, n)
}

# Merge array x of size n, if units of length block are pre-sorted
def merge_from{dn, x:pT, n:U, aux:pT, block} = {
  def T = eltype{pT}
  src:=x; dst:=aux
  w:U = block; while (w < n) {
    ww:=2*w
    i:U=0; while (i < n-w) {
      l := n-i; if (l>ww) l=ww
      parity_merge_any{dn, T}(dst+i, src+i, w, l)
      i += ww
    }
    if (i < n) set{dst+i, src+i, n-i}
    t:=src; src=dst; dst=t  # <-> doesn't work because they're pointers, oops
    w = ww
  }
  if (src != x) set{x, src, n}
}

# A bottom-down fast but not very adaptive merge sort
# Requires dst != aux; src may be dst or aux
pisort{dn, T}(dst:*+T, src:*+T, n:U, aux:*T) : void = {
  pisort{dn, bind{call, pisort{dn,T}}, dst, src, n, aux}
}
def pisort{dn, recur, dst, src, n:U, aux} = {
  if (n < 32) {
    sort_lt32{dn, dst, src, n}
    return{}
  }

  h1 := n / 2; h2 := n - h1

  recur{aux,      src,      h1, dst}
  recur{aux + h1, src + h1, h2, dst + h1}

  if (aux->(h1-1) <={dn} aux->h1) {
    eachrec{{d,a}=>set{d,a,n}, dst, aux}
  } else {
    parity_merge_fn{dn, 1, dst, aux, h1, n}
  }
}

# Allow index part of src to be just a base index
pisort{dn, T, I}(dst:tup{*T,*I}, src:tup{*T,I}, n:U, aux:tup{*T,*I}) : void = {
  pisort{dn, bind{call, pisort{dn,T,I}}, dst, src, n, aux}
}
pigrade{dn, T, I}(dst:*I, src:*T, n:U, aux:*void) : void = {
  ai := *I~~aux
  dv := *T~~(ai + n)
  av := dv + n
  pisort{dn, T, I}(tup{dv, dst}, tup{src, 0}, n, tup{av, ai})
}
