# Merge sorting

# Merge arrays of length l and n-l starting at a, using buffer aux.
# Branchy and slow
def branch_merge{a:pT, l:U, n:U, aux:pT} = {
  set{aux, a, l}
  ai:U=0; bi:U=l; i:U=0
  while (i < bi) {
    def pick{arr,ind} = { a <-{i} arr->ind; ++ind }
    if (bi >= n or aux->ai <= a->bi) {
      pick{aux,ai}
    } else {
      pick{a  ,bi}
    }
    ++i
  }
}

# Parity merge: branchless
# Main data movement
def parity_pos{left, right, dst} = {
  l := left->0; r := right->0
  c := l <= r; d := ~c
  dst <-{c} r; right += d
  dst <-{d} l; left  += c
  ++dst
}
def parity_neg{left, right, dst} = {
  l := left->0; r := right->0
  c := l <= r; d := ~c
  --dst
  dst <-{c} r; right -= c
  dst <-{d} l; left  -= d
}
def sel{cmp, a, b} = { r := b; if (cmp{single{a},single{b}}) r = a; r }

# Merge halves of length-n array with constant n (4 and 8 used)
def parity_merge_const{n, dst, src} = {
  def h = n / 2
  left := clone{src}; right := src + h; dstc := clone{dst}
  @for_const (h-1) parity_pos{left, right, dstc}
  dstc <- sel{<=, left->0, right->0}

  left = src + (h-1); right = src + (n-1); dstc = dst + (n-1)
  @for_const (h-1) parity_neg{left, right, dstc}
  dstc <- sel{ >, left->0, right->0}
}

# Merge halves of array
parity_merge{T, handle_odd}(dst:*T, src:*T, half:usize, n:usize) : void = {
  lpos := src           ; rpos := src + half ; dpos := dst
  lneg := src + half - 1; rneg := src + n - 1; dneg := dst + n - 1

  if (handle_odd and n%2) {
    l := lpos->0; r := rpos->0
    if (l <= r) { dst<-l; ++lpos }
    else        { dst<-r; ++rpos }
    ++dpos
  }
  @for (n/2 - 1) {
    parity_pos{lpos, rpos, dpos}
    parity_neg{lneg, rneg, dneg}
  }
  dpos <- sel{<=, *lpos, *rpos}
  dneg <- sel{ >, *lneg, *rneg}
}

# Check for easy cases when the merge can be avoided
# If the buffer helping at all, most merges go through these
def merge_chk{a:pT, l:U, n:U, aux:pT} = {
  if (a->(l-1) <= a->l) {
    0
  } else if (a->(n-1) < a->0 and l+l==n) {
    b := a+l
    map{<->, a, b, l}
  } else {
    branch_merge{a,l,n,aux}
  }
}

# Merge array x of size n, if units of length block are pre-sorted
def merge_from{merge}{x:pT, n:U, aux:pT, block} = {
  w:U = block; while (w < n) {
    ww:=2*w
    i:U=0; while (i < n-w) {
      l := n-i; if (l>ww) l=ww
      merge{x+i, w, l, aux}
      i += ww
    }
    w = ww
  }
}

# A simple bottom-down and not-very-adaptive merge sort using
# branchless merges in sets of 4
piposort{T}(x:*T, n:usize, aux:*T) : void = {
  if (n < 32) {
    sort_lt32{x, n}
    return{}
  }
  # Approximate halves n = h1+h2 and quarters h1=q1+q2, h2=q3+q4
  h1 := n / 2;  q1 := h1 / 2; q2 := h1 - q1
  h2 := n - h1; q3 := h2 / 2; q4 := h2 - q3

  # Sort each quarter
  def recur = piposort{T}
  recur(x          , q1, aux)
  recur(x + q1     , q2, aux)
  recur(x + h1     , q3, aux)
  recur(x + h1 + q3, q4, aux)

  # If each boundary between quarters is ordered, we're done
  def ord{i} = x->(i-1) <= x->i
  if (ord{q1} and ord{h1} and ord{h1 + q3}) return{}

  # Also check for reversed quarters
  if (x->0 > x->(h1-1) and x->q1 > x->(h1+q3-1) and x->h1 > x->(n-1)) {
    set{aux, x, h1}
    set{x,     x + h1 + q3, q4}
    set{x + q4,     x + h1, q3}
    set{x + h2,   aux + q1, q2}
    set{x + h2 + q2,   aux, q1}
    return{}
  }

  def merge = parity_merge{T, 1}
  merge(aux     , x     , q1, h1)
  merge(aux + h1, x + h1, q3, h2)
  merge(x       , aux   , h1, n)
}
