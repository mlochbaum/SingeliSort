# Minimum size to steal from buffer
def BLOCK = 16
# Initial barrier before stealing anything
def thresh_init = 2*BLOCK

# Main Robin Hood insertion algorithm
# Fill and empty the buffer. Doesn't include merges.
def rh_insert{x:*T, len:U, buf:*T, buflen, pos, empty:T} = {
  set{buf, empty, buflen}

  # Stolen blocks go to xb
  xb := x
  threshold:U = thresh_init

  # Main loop: insert array entries into buffer
  @for (x over i from 0 to len) {
    j:U = pos{x}
    h:T = buf->j
    if (LIKELY{h==empty}) {
      # Easy insert
      buf <-{j} x
    } else {
      # Collision
      end := insertval{j, x, h, buf, empty}
      # Big collision
      if (RARE{end-j >= threshold}) {
        threshold = BLOCK
        stealblocks{j, end, buf, xb, pos, empty}
      }
    }
  }

  # Move all values from the buffer back to the array
  xt := filter_neq{xb, buf, buflen, empty}
  # Recover sentinel elements based on total count
  set{xt, empty, (x+len)-xt}

  xb
}

# Insert an element val to buf at init (cur := buf->init)
# Return the location after the last value moved
def insertval{init:U, val:T, cur:T, buf:*T, empty:T} = {
  ins:=init; end:=init
  # Reposition elements after val branchlessly during the search
  do {
    ++end; n := buf->end  # Might write over this
    def c = val >= cur    # If we have to move past that entry
    buf <-{end-c} cur     # Reposition cur
    ins += c              # Increments until val's final location found
    cur = n
  } while (cur!=empty)    # Until the end of the chain
  buf <-{ins} val
  1+end   # Account for just-inserted val
}

def stealblocks{start:U, end:U, buf:*T, dst:*T, pos, empty:T} = {
  def j = start
  # Find the beginning of the chain (required for stability)
  while ((j>0) & (buf->(j-1)!=empty)) --j
  # Move as many blocks from it as possible
  hj := buf+j; hf := buf+end
  while (hj <= hf-BLOCK) {
    @for (hj, dst over i to BLOCK) { dst = hj; hj = empty }
    hj += BLOCK; dst += BLOCK
  }
  # Leftover elements might have to move backwards
  pr:U = j
  while (hj < hf) {
    e := *hj; hj <- empty; ++hj
    p:=pos{e}; if (p>pr) pr = p
    buf <-{pr} e; ++pr
  }
}

# Statistical check of samples to make sure it's not too clumpy
def checkdist{sample, num:U, pos} = {
  prev := pos{sample->0}
  score:U = 0
  @for (sample over i from 1 to num) {
    next:=pos{sample}; d:=next-prev; prev=next
    if (d<16) { score+=16-d; if (score>=60+num/6) return{0} }
  }
}

def rh_main{merge, merge_from, alloc, check}{x:*T, n:U, minv:T, maxv, r} = {
  sh:U = 0                              # Contract to fit range
  while (r>5*n) { ++sh; r=r>>1 }        # Shrink to stay at O(n) memory
  def pos{v} = dist{U,minv,v} >> sh

  # Goes down to BLOCK once we know we have to merge
  sz:U = r + thresh_init                # Buffer size
  aux := alloc{sz}
  check{pos}

  # Treat maxv as "empty": the buffer will swallow these,
  # but they can be recovered by counting
  empty := maxv
  xb := rh_insert{x, n, aux, sz, pos, empty}

  # Merge stolen blocks back in if necessary
  l:U = U<~(xb-x)   # Size of those blocks
  if (l > 0) {
    # Sort x[0..l]
    merge_from{x, l, aux, BLOCK}
    # And merge with the rest of x
    merge{x, l, n, aux}
  }
}

# Sort array of ints with length n.
# Assume there's enough aux space.
rh_sort{U, T, merge, merge_from, range}(x:*T, n:U, aux:*T) : void = {
  # Find the range.
  def mm=range{x, n}; minv:=tupsel{0,mm}; maxv:=tupsel{1,mm}
  r:U = dist{U, minv, maxv}            # Size of range
  if (r/4 < n) {
    count_sort{x, n, *U~~aux, minv, r+1}
  } else {
    rh_main{merge, merge_from, {sz}=>aux, {pos}=>1}{x, n, minv, maxv, r}
  }
}
