# Prefix sums

# Prefix sum on the size-wi units of word(s) x of width ww
# Values in x must be registers: the sum is done in place
local def prefix_word{wi, ww, x} = {
  # Shift amounts, e.g. tup{8, 16, 32}
  def shifts{w} = { if (w<ww) merge{w, shifts{2*w}}; else tup{} }
  # Add each of these in succession, interleaving if x is a tuple
  each{{k} => {x += x<<k}, shifts{wi}}
}
# Add incoming values first
local def prefix_word{wi, ww, x, add} = {
  x += add
  prefix_word{wi, ww, x}
}

# Inclusive, probably slightly faster
# Used by counting sort
# If dn==1, subtract instead of adding
def prefix_sum{dn} = {
  # Basic pattern, mutates sum
  def psf{cfor}{x:*T, len, sum:T} = {
    @cfor (x over len) {
      sum +={dn} x
      x = sum
    }
  }

  def ps{x:*T, len, init:T} = psf{for_unroll{4}}{x, len, clone{init}}

  # SWAR optimization for 1- or 2-byte counts and no SIMD
  def ps{x:*T, len, init:T & width{T}<=16} = {
    def wc = width{T}; def ww = width{usize}
    def l = ww / wc
    nw := len / l
    xw := *usize~~x
    sum := usize^~primtype{'u',wc}~~init
    # Adjust for signed overflow and descending with xor
    def fixsum = { if (not (issigned{T} or dn)) { {s}=>s } else {
      def off = (1<<(width{T}-1)) - dn
      sum ^= off
      xor:usize = off; prefix_word{wc, ww, xor, 0}
      {s} => xor ^ s
    } }
    @for (xw over nw) {
      prefix_word{wc, ww, sum, xw}
      xw = fixsum{sum}
      sum >>= ww-wc
    }
    lenq := l * nw
    psf{for}{x + lenq, len - lenq, clone{T<~fixsum{sum}}}
  }

  def ps{x:pT, len} = ps{x, len, eltype{pT}~~0}
  ps
}

# Exclusive, interleaved
def prefix_sum_excl = {
  def ps{ptrs, len, signed & ktup{ptrs}} = {
    # Running total initialized to 0 for each array
    def sum = each{{_:pT}=>{s:eltype{pT}=0}, ptrs}
    # Do the sums
    @for (x in ptrs over len) {
      def prev = clone{sum}
      sum += x
      x = prev
    }
  }

  def setw{c} = width{eltype{type{tupsel{0,c}}}} # single element type width

  # SWAR optimization for 1- or 2-byte counts and no SIMD
  # Assumes total size is a whole number of words
  def ps{ptrs, len, signed & ktup{ptrs} & 16>=setw{ptrs}} = {
    # Width of count and word
    def wc = setw{ptrs}; def ww = width{usize}
    # Word pointers
    def pwords = each{bind{~~,*usize}, ptrs}
    # Sum registers initialized to 0
    def sum = each{{_}=>{s:usize=0}, ptrs}
    # Length of the loop
    @for (x in pwords over len * wc / ww) {
      def prev = clone{sum}
      prefix_word{wc, ww, sum, x}
      x = prev | sum<<wc
      sum >>= ww-wc
    }
  }
  ps
}
