# Prefix sums

# Prefix sum on the size-wi units of word(s) x of width ww
# Values in x must be registers: the sum is done in place
def prefix_word{wi, ww, x} = {
  # Shift amounts, e.g. tup{8, 16, 32}
  def shifts{w} = { if (w<ww) merge{w, shifts{2*w}}; else tup{} }
  # Add each of these in succession, interleaving if x is a tuple
  each{{k} => {x += x<<k}, shifts{wi}}
}
# Add incoming values first
def prefix_word{wi, ww, x, add} = {
  x += add
  prefix_word{wi, ww, x}
}

# Inclusive, probably slightly faster
# Used by counting sort
def prefix_sum = {
  # Basic pattern, mutates sum
  def psf{cfor}{x:*T, len, sum:T} = {
    @cfor (x over len) {
      sum += x
      x = sum
    }
  }

  def ps{x:*T, len, init:T} = psf{for_unroll{4}}{x, len, clone{init}}

  # SWAR optimization for 1- or 2-byte counts and no SIMD
  def ps{x:*T, len, init:T & width{T}<=16} = {
    def wc = width{T}; def ww = width{usize}
    def l = ww / wc
    nw := len / l
    xw := *usize~~x
    sum := usize^~primtype{'u',wc}~~init
    # Adjust for signed overflow with xor
    def fixsum = { if (not issigned{T}) { {s}=>s } else {
      def off = 1<<(width{T}-1)
      x <-{0} x->0 ^ -off
      xor:usize = off; prefix_word{wc, ww, xor, 0}
      {s} => xor ^ s
    } }
    @for (xw over nw) {
      prefix_word{wc, ww, sum, xw}
      xw = fixsum{sum}
      sum >>= ww-wc
    }
    lenq := l * nw
    psf{for}{x + lenq, len - lenq, clone{T<~fixsum{sum}}}
  }

  def ps{x:pT, len} = ps{x, len, eltype{pT}~~0}
  ps
}

# Exclusive, interleaved
def prefix_sum_excl = {
  def sign_inds{s, i, len, tup} = i
  def sign_inds{s==1, i, len, tup} = {
    def j = (i + len / 2) & (len - 1)
    shiftleft{each{{_}=>i, tup}, j}
  }

  def ps{ptrs, signed & ktup{ptrs}} = {
    # Running total initialized to 0 for each array
    def sum = each{{_:pT}=>{s:eltype{pT}=0}, ptrs}
    # Do the sums
    @for (x in ptrs over i to count_len) {
      def prev = clone{sum}
      def is = sign_inds{signed, i, count_len, x}
      sum += x
      x = prev
    }
  }

  def setw{c} = width{eltype{type{tupsel{0,c}}}} # single element type width

  # SWAR optimization for 1- or 2-byte counts and no SIMD
  def ps{ptrs, signed & ktup{ptrs} & 16>=setw{ptrs}} = {
    # Width of count and word
    def wc = setw{ptrs}; def ww = width{usize}
    # Word pointers
    def pwords = each{bind{~~,*usize}, ptrs}
    # Sum registers initialized to 0
    def sum = each{{_}=>{s:usize=0}, ptrs}
    # Length of the loop
    def len = count_len * wc / ww
    @for (i to len) {
      def prev = clone{sum}
      def is = sign_inds{signed, i, len, ptrs}
      prefix_word{wc, ww, sum, pwords->is}
      pwords <-{is} prev | sum<<wc
      sum >>= ww-wc
    }
  }
  ps
}
