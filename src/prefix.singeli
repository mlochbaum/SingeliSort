# Prefix sums

# Prefix sum on the size-wi units of word(s) x of width ww
# Values in x must be registers: the sum is done in place
def prefix_word{wi, ww, x} = {
  # Shift amounts, e.g. tup{8, 16, 32}
  def shifts{w} = { if (w<ww) merge{w, shifts{2*w}}; else tup{} }
  # Add each of these in succession, interleaving if x is a tuple
  each{{k} => {x += x<<k}, shifts{wi}}
}
# Add incoming values first
def prefix_word{wi, ww, x, add} = {
  x += add
  prefix_word{wi, ww, x}
}

# Inclusive, probably slightly faster
# Used by counting sort
def prefix_sum = {
  # Basic pattern, mutates sum
  def psf{cfor}{x:*T, len, sum:T} = {
    @cfor (x over i from 0 to len) {
      sum += x
      x = sum
    }
  }

  def ps{x:*T, len, init:T} = psf{for_unroll{4}}{x, len, clone{init}}

  # SWAR optimization for 1- or 2-byte counts and no SIMD
  def ps{x:*T, len, init:T & width{T}<=16} = {
    def wc = width{T}; def ww = width{usize}
    def l = ww / wc
    nw := len / l
    xw := *usize~~x
    sum := usize^~primtype{'u',wc}~~init
    # Adjust for signed overflow with xor
    def fixsum = { if (not issigned{T}) { {s}=>s } else {
      def off = 1<<(width{T}-1)
      x <-{0} x->0 ^ -off
      xor:usize = off; prefix_word{wc, ww, xor, 0}
      {s} => xor ^ s
    } }
    @for (xw over i to nw) {
      prefix_word{wc, ww, sum, xw}
      xw = fixsum{sum}
      sum >>= ww-wc
    }
    lenq := l * nw
    psf{for}{x + lenq, len - lenq, clone{T<~fixsum{sum}}}
  }

  def ps{x:pT, len} = ps{x, len, eltype{pT}~~0}
  ps
}

# Exclusive, interleaved
def prefix_sum_excl{ptrs & istup{ptrs}} = {
  # Running total initialized to 0 for each array
  def sum = each{{_:pT}=>{s:eltype{pT}=0}, ptrs}
  # Do the sums
  @for (i to count_len) {
    def prev = clone{sum}
    sum += ptrs -> i
    ptrs <-{i} prev
  }
}

def setw{c} = width{eltype{type{tupsel{0,c}}}} # single element type width

# SWAR optimization for 1- or 2-byte counts and no SIMD
def prefix_sum_excl{ptrs & istup{ptrs} & 16>=setw{ptrs}} = {
  # Width of count and word
  def wc = setw{ptrs}; def ww = width{usize}
  # Word pointers
  def pwords = each{bind{~~,*usize}, ptrs}
  # Sum registers initialized to 0
  def sum = each{{_}=>{s:usize=0}, ptrs}
  # Shift amounts, e.g. tup{8, 16, 32}
  def shifts{w} = { if (w<ww) merge{w, shifts{2*w}}; else tup{} }
  # Okay, let's begin
  @for (i to count_len * wc / ww) {
    def prev = clone{sum}
    prefix_word{wc, ww, sum, pwords->i}
    pwords <-{i} prev | sum<<wc
    sum >>= ww-wc
  }
}
