# Utilities likely to be useful for multiple sorting algorithms
include './prefix'

def map{op, a, b, n} = @for (a over n) op{a,b}
def map{op, a, b:T, n & tptr{T}} = @for (a, b over n) op{a,b}

# memset/memcpy
def set = bind{map, {a,b} => {a=b}}

def filter_neq{dst, src, len, v} = {
  d:=dst; l:=len
  s1:=src-1; while (s1->l == v) --l
  @for_unroll{8} (src over i to l) {
    d <- src; d += v != src  # Branchless update
  }
  d
}

def findrange{arr, len} = {
  minv:=arr->0; maxv:=minv;
  @for (arr over i from 1 to len) {
    if (arr<minv) minv=arr; if (arr>maxv) maxv=arr;
  }
  tup{minv,maxv}
}
def readrange{arr, len} = tup{arr->(-1), arr->len}

def dist{U,a:T,b:T} = U ^~ primtype{'u',width{T}} ~~ (b-a)

# Try the given types to lower constant overhead on small arrays
def index_options{sort, n:U, test, itypes} = {
  def try{C} = { if (C<U and LIKELY{test{n,C}}) return{sort{C}} }
  each{try, itypes}
  sort{U}
}
