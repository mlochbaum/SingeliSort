# Utilities likely to be useful for multiple sorting algorithms
include './prefix'

def map{op, a, b, n} = @for (a over n) op{a,b}
def map{op, a, b:T, n & tptr{T}} = @for (a, b over n) op{a,b}

# memset/memcpy
def set = bind{map, {a,b} => {a=b}}

def reverse{x:T, n & tptr{T}} = {
  xr := x + n-1
  @for (i to n/2) x+i <-> xr-i
}

def filter_neq{dst, src, len, v} = {
  d:=dst; l:=len
  s1:=src-1; while (s1->l == v) --l
  @for_unroll{8} (src over i to l) {
    d <- src; d += v != src  # Branchless update
  }
  d
}

def findrange{arr, len} = {
  minv:=arr->0; maxv:=minv;
  @for (arr over i from 1 to len) {
    if (arr<minv) minv=arr; if (arr>maxv) maxv=arr;
  }
  tup{minv,maxv}
}
def readrange{arr, len} = tup{arr->(-1), arr->len}

def dist{a:T, b:T} = primtype{'u',width{T}} ~~ (b-a)
def dist{U,a,b} = U ^~ dist{a,b}

# Try the given types to lower constant overhead on small arrays
def index_options{sort, n:U, test, itypes} = {
  def done = makelabel{}
  def try{C} = { if (C<U and LIKELY{test{n,C}}) { sort{C}; goto{done} } }
  each{try, itypes}
  sort{U}
  setlabel{done}
}
