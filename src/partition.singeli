# Partition algorithms for quicksort

# Stable partitioning with external memory
# Place values v into dst_false or dst_true according to cmp{v, piv}
# Return the number of true comparisons, or length of dst_true
def flux_partition{src:*T, cmp, piv:T, dst_true:*T, dst_false:*T, n:U} = {
  # Number of true comparisons, and index into dst_true
  l:U = 0
  dst_f := dst_false
  @for_unroll{8} (src over n) {
    c := cmp{src, piv}
    # Write to both destinations: one will be overwritten
    dst_true <-{ l} src
    dst_f    <-{-l} src; ++dst_f
    l += c
  }
  l
}

# Unstable in-place partitioning
def fulcrum_partition{x:*T, cmp, piv:T, aux:*T, n:U} = {
  def bl = 16
  dst_left  := x;      src_left  := dst_left  + bl
  dst_right := x + n;  src_right := dst_right - bl

  set{aux,      dst_left,  bl}
  set{aux + bl, src_right, bl}

  m:U = 0
  def put{ptr} = {
    v := *ptr
    c := cmp{v, piv}
    dst_left  <-{m} v; --dst_right
    dst_right <-{m} v
    m += c
  }
  def part{num} = {
    diff := src_left - dst_left - m
    if (diff < bl) { @for (num) { put{src_left }; ++src_left  } }
    else           { @for (num) { --src_right; put{src_right} } }
  }

  @for (n / bl - 2) part{bl}
  part{n % bl}
  @for (2*bl) { put{aux}; ++aux }
  m
}
