# Base definitions that determine how "our version" of Singeli works

# Mostly it looks like C
include 'arch/c'    # Backend
include 'skin/c'    # Operators
include 'skin/cext'

include 'util/tup'  # List utilities: scan and so on
include 'util/kind' # Kind-test functions like ktup
def range = iota

oper <-> swap        infix none  20
oper >*  ptr_gt      infix none  20
oper *?  lazy_load   prefix      60
oper *?  lazy_load   infix right 50
oper *+  pnt_each    prefix      60
oper >   single      prefix      80

def tptr{T} = 'pointer'===typekind{T}

local def first{t} = tupsel{0,t}
def single{x} = (if (ktup{x}) first{x}; else x)

def can_use_unstable{x} = 1
def can_use_unstable{x & ktup{x}} = 1 == tuplen{x}

def swap{a, b} = { t:=a; a=b; b=t }
def swap{a:T, b:T & tptr{T}} = { t := *a; a <- *b; b <- t }

def __pnt{t & ktup{t}} = __pnt{single{t}}
def ptr_gt{a,b} = load{a,0} > load{b,0}
def ptr_lt{a,b} = load{a,0} < load{b,0}

def usize = primtype{'u',width{*void}}
def U = usize
def bytes{t & ktyp{t}} = width{t} / 8

# Change to unsigned: here we always subtract smaller from greater
def __sub{a:P,b:P & tptr{P}}  = emit{usize, 'op -', a, b}

def addtype{a:T} = { if (tptr{T}) usize; else T }
def __add{a, b:u1} = __add{a, addtype{a}^~b}
def __sub{a, b:u1} = __sub{a, addtype{a}^~b}

def clone{old} = { new:=old }

def leading_zeros{x:u64} = u8 <~ emit{i32, '__builtin_clzll', x}

def expect{e}{X} = emit{type{X}, '__builtin_expect', X,e}
def RARE   = expect{0}
def LIKELY = expect{1}

# Pervasion
local include 'util/perv'
extend perv1{clone}
extend perv2{load}
extend (perv{3}){store}
extend perv2{__add}
extend perv2{__sub}
extend perv2{__or }
extend perv2{__shl}
extend perv2{__shr}
extend perv1{__decr}
def eachrec{fn,...a} = { (extend (perv{tuplen{a}}){fn}){...a} }

local def extend ecmp{f,g} = {
  def f{a,b & ktup{a} & ktup{b}} = f{first{a},first{b}}
  def f{dn==0} = f
  def f{dn==1} = g
}
local def dn_ind = tup{0,1, 3,2, 5,4, 7,6}
extend ({...f}=>each{ecmp,f,tupsel{dn_ind,f}}){
  __eq, __ne, __lt, __gt, __le, __ge,
  ptr_gt, ptr_lt
}

def pnt_each{...T} = eachrec{__pnt, ...T}

# ++{1} is -- and +={1} is -=
def __incr{dn==0} = __incr
def __incr{dn==1} = __decr

# -{1} swaps arguments
def __sub{dn==0} = __sub
def __sub{dn==1}{a,b} = b-a

def type{s & ktup{s}} = type{first{s}}
def scaltype{T} = (if (tptr{T}) scaltype{eltype{T}}; else T)
def scaltype{x & ~ktyp{x}} = scaltype{type{x}}

def isid{ptr} = ~tptr{type{ptr}}
def load{ptr, i & isid{ptr}} = ptr + i
def store{ptr=='sink', i, val} = val
def __add{ptr=='sink', i} = 'sink'

def lazy_load{p} = lazy_load{p,0}
def lazy_load{p,i} = {
  def s = load{single{p},single{i}}
  if (not ktup{p}) s; else {
    def ll{p,i}{} = load{p,i}
    def pr = slice{p,1}
    merge{
      tup{s},
      (if (ktup{i}) each{ll, pr, slice{i,1}}; else each{{p}=>ll{p,i},pr})
    }
  }
}
def store{p, i, val & kgen{val}} = store{p, i, val{}}
def get{a} = a
def get{a & kgen{a}} = a{}
extend perv1{get}

def for{vars,begin,end,block} = {
  def e = usize^~end
  i := usize^~begin
  while (i < e) {
    exec{i, vars,block}
    i += 1
  }
}
def for_backwards{vars,begin,end,block} = {
  i := usize^~end
  def e = usize^~begin
  while (i > e) {
    i -= 1
    exec{i, vars,block}
  }
}
def for_const{vars,begin,end,block} = {
  if (begin < end) {
    for_const{vars,begin, end-1, block}
    exec{end-1, vars,block}
  }
}
def for_unroll{unr}{vars,begin,end,block} = {
  def e = usize^~end
  i:usize = begin
  eu := e & ~ usize~~(unr-1)
  while (i < eu) {
    @for_const (j to unr) exec{i+j, vars,block}
    i += unr
  }
  while (i < e) {
    exec{i, vars,block}
    i += 1
  }
}
