# Base definitions that determine how "our version" of Singeli works

# Mostly it looks like C
include 'arch/c'    # Backend
include 'skin/c'    # Operators
include 'skin/cext'

include 'util/tup'  # List utilities: scan and so on
def range = iota

oper <-> swap        infix none  20
oper >*  ptr_gt      infix none  20

def ktup{t} = 'tuple'===kind{t}
def tptr{T} = 'pointer'===typekind{T}

def single{x} = (if (ktup{x}) tupsel{0,x}; else x)

def swap{a, b} = { t:=a; a=b; b=t }
def swap{a:T, b:T & tptr{T}} = { t := *a; a <- *b; b <- t }

def ptr_gt{a,b} = load{a,0} > load{b,0}

def usize = primtype{'u',width{*void}}

# Change to unsigned: here we always subtract smaller from greater
def __sub{a:P,b:P & tptr{P}}  = emit{usize, 'op -', a, b}

def addtype{a:T} = { if (tptr{T}) usize; else T }
def __add{a, b:u1} = __add{a, addtype{a}^~b}
def __sub{a, b:u1} = __sub{a, addtype{a}^~b}

def clone{old} = { new:=old }

def expect{e}{X} = emit{type{X}, '__builtin_expect', X,e}
def RARE   = expect{0}
def LIKELY = expect{1}

# Pervasion for interleaved prefix sums
local include 'util/perv'
extend perv1{clone}
extend perv2{load}
extend (perv{3}){store}
extend perv2{__add}
extend perv2{__or }
extend perv2{__shl}
extend perv2{__shr}

def type{s & ktup{s}} = type{tupsel{0,s}}
def scaltype{T} = (if (tptr{T}) scaltype{eltype{T}}; else T)
def scaltype{x & ~('type'===kind{x})} = scaltype{type{x}}

def load{ptr=='id', i} = i
def store{ptr=='sink', i, val} = val

def for{vars,begin,end,block} = {
  def e = usize^~end
  i:usize = begin
  while (i<e) {
    exec{i, vars,block}
    i += 1
  }
}
def for_const{vars,begin,end,block} = {
  if (begin<end) {
    for_const{vars,begin,end-1,block}
    exec{end-1, vars,block}
  }
}
def for_unroll{unr}{vars,begin,end,block} = {
  def e = usize^~end
  i:usize = begin
  eu := e & ~ usize~~(unr-1)
  while (i<eu) {
    @for_const (j to unr) exec{i+j, vars,block}
    i += unr
  }
  while (i<e) {
    exec{i, vars,block}
    i += 1
  }
}

def print{x:T & isint{T}} = emit{void,'printf','"%d\n"',x}
def print{x:u64} = emit{void,'printf','"%ld\n"',x}
