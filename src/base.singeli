# Base definitions that determine how "our version" of Singeli works

# Mostly it looks like C
include 'arch/c'    # Backend
include 'skin/c'    # Operators
include 'skin/cext'

include 'util/tup'  # List utilities: scan and so on
def range = iota

oper <-> swap        infix none  20

oper >*  ptr_gt      infix none  20

def swap{a, b} = { t:=a; a=b; b=t }
def swap{a:T, b:T & 'pointer'===typekind{T}} = { t := *a; a <- *b; b <- t }

def usize = primtype{'u',width{*void}}

# Change to unsigned: here we always subtract smaller from greater
def __sub{a:P,b:P & match{'pointer',typekind{P}}}  = emit{usize, 'op -', a, b}

def addtype{a:T} = T
def addtype{a:T & match{'pointer',typekind{T}}} = usize
def __add{a, b:u1} = __add{a, addtype{a}^~b}
def __sub{a, b:u1} = __sub{a, addtype{a}^~b}

def expect{e}{X} = emit{type{X}, '__builtin_expect', X,e}
def RARE   = expect{0}
def LIKELY = expect{1}

def for{vars,begin,end,block} = {
  def e = usize^~end
  i:usize = begin
  while (i<e) {
    exec{i, vars,block}
    i = i+1
  }
}
def for_const{vars,begin,end,block} = {
  if (begin<end) {
    for_const{vars,begin,end-1,block}
    exec{end-1, vars,block}
  }
}
def for_unroll{unr}{vars,begin,end,block} = {
  def e = usize^~end
  i:usize = begin
  eu := e & ~cast{usize,unr-1}
  while (i<eu) {
    @for_const (j to unr) exec{i+j, vars,block}
    i += unr
  }
  while (i<e) {
    exec{i, vars,block}
    i += 1
  }
}

# Some ad-hoc tuple mapping for interleaved prefix sums
def istup{t} = 'tuple'===kind{t}
def clone{old} = { new:=old }
def clone{o & istup{o}} = each{clone,o}
def load{p, i & istup{p}} = each{{p}=>load{p,i}, p}
def store{p, i, v & istup{p}} = each{{p,v}=>store{p,i,v}, p,v}
def load{p, i & istup{p} & istup{i}} = each{load, p,i}
def store{p, i, v & istup{p} & istup{i}} = each{store, p,i,v}
def __add{a, b & istup{a} & istup{b}} = each{__add, a, b}
def __or{a, b & istup{a} & istup{b}} = each{__or, a, b}
def __shl{a, b & istup{a}} = each{{a}=>__shl{a,b}, a}
def __shr{a, b & istup{a}} = each{{a}=>__shr{a,b}, a}

def ptr_gt{a,b} = load{a,0} > load{b,0}

def print{x:T & isint{T}} = emit{void,'printf','"%d\n"',x}
def print{x:u64} = emit{void,'printf','"%ld\n"',x}
