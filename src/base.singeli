# Base definitions that determine how "our version" of Singeli works

# Mostly it looks like C
include 'arch/c'    # Backend
include 'skin/c'    # Operators
include 'skin/cext'

include 'util/tup'  # List utilities: scan and so on
def range = iota

oper <-> swap        infix none  20
oper >*  ptr_gt      infix none  20

def tptr{T} = 'pointer'===typekind{T}

def swap{a, b} = { t:=a; a=b; b=t }
def swap{a:T, b:T & tptr{T}} = { t := *a; a <- *b; b <- t }

def ptr_gt{a,b} = load{a,0} > load{b,0}

def usize = primtype{'u',width{*void}}

# Change to unsigned: here we always subtract smaller from greater
def __sub{a:P,b:P & tptr{P}}  = emit{usize, 'op -', a, b}

def addtype{a:T} = { if (tptr{T}) usize; else T }
def __add{a, b:u1} = __add{a, addtype{a}^~b}
def __sub{a, b:u1} = __sub{a, addtype{a}^~b}

def clone{old} = { new:=old }

def expect{e}{X} = emit{type{X}, '__builtin_expect', X,e}
def RARE   = expect{0}
def LIKELY = expect{1}

def for{vars,begin,end,block} = {
  def e = usize^~end
  i:usize = begin
  while (i<e) {
    exec{i, vars,block}
    i += 1
  }
}
def for_const{vars,begin,end,block} = {
  if (begin<end) {
    for_const{vars,begin,end-1,block}
    exec{end-1, vars,block}
  }
}
def for_unroll{unr}{vars,begin,end,block} = {
  def e = usize^~end
  i:usize = begin
  eu := e & ~ usize~~(unr-1)
  while (i<eu) {
    @for_const (j to unr) exec{i+j, vars,block}
    i += unr
  }
  while (i<e) {
    exec{i, vars,block}
    i += 1
  }
}

# Some ad-hoc tuple mapping for interleaved prefix sums
def ktup{t} = 'tuple'===kind{t}
local oper \ ktup prefix 40
def clone{o & \o} = each{clone,o}
def load {p, i    & \p} = each{{p  }=>load {p,i  }, p  }
def store{p, i, v & \p} = each{{p,v}=>store{p,i,v}, p,v}
def load {p, i    & \p & \i} = each{load , p,i  }
def store{p, i, v & \p & \i} = each{store, p,i,v}
def __add{a, b & \a & \b} = each{__add, a, b}
def __or {a, b & \a & \b} = each{__or, a, b}
def __shl{a, b & \a} = each{{a}=>__shl{a,b}, a}
def __shr{a, b & \a} = each{{a}=>__shr{a,b}, a}

def print{x:T & isint{T}} = emit{void,'printf','"%d\n"',x}
def print{x:u64} = emit{void,'printf','"%ld\n"',x}
