# LSD Radix sort (includes bucket sort as the 1-step case)
# Sorts the array according to the least significant byte, then the
# next higher, and so on.
# It has the best "generic" performance of any algorithm here, but has
# no adaptivity and in fact slows down on some fairly common patterns
# due to cache associativity. So while the implementation here is
# general, only the 1- and 2-byte forms are used for hybrid sorting.

local {

# Fix the radix at 1 byte because other widths take too much computation
def radix_bits = 8
def count_len  = 1<<radix_bits

# Number of steps required
def getsteps{x} = width{scaltype{x}} / radix_bits

# Given a tuple, get corresponding key generators: bytes starting from
# the bottom
def keyfns{len} = {
  def kf{sh}{v} = u8<~(v>>sh)
  each{kf, range{len} * radix_bits}
}

# Sort the n values in x with a number of radix passes equal to steps
# Store counts in count, which must hold steps*count_len counts
# The result for step i is stored at tupsel{i,dsts}
def radix_main{src, n:U, dsts, count:pC} = {
  def steps = tuplen{dsts}
  # Tuple of zeroed count arrays
  def counts = init_counts{count, steps}
  # Count frequency of all bytes simultaneously
  def keys = keyfns{steps}
  radix_counts{single{src}, n, counts, keys}
  # Exclusive sum of each count array (interleaved for speed)
  prefix_sum_excl{counts, count_len, issigned{scaltype{src}}}
  # And do the radix sorting through the successive dsts
  def srcs = shiftright{tup{src}, dsts}
  each{radix_move{n}, srcs, dsts, counts, keys}
}

# Zero and split into num arrays with count_len values each
def init_counts{space:pT, num} = {
  set{space, 0, num*count_len}
  scan{+, merge{space, copy{num-1, count_len}}}
}

# Perform all counts in a single pass
def radix_counts{x, n, counts, keys} = {
  @for (x over n) {
    def incr{c, k} = incrp{c + k{x}}
    each{incr, counts, keys}
  }
}

# One step of radix sorting
def radix_move{n}{src, dst, count, key} = {
  @for (src over n) {
    def k = key{single{src}}
    c := count->k
    dst <-{c} src
    count <-{k} c+1
  }
}

} # end local

# Swap back and forth with aux, ending with the elements in x again
def radix_inplace{x:pT, n:U, aux:pT, count:pC} = {
  def steps = getsteps{x}
  radix_main{x, n, cycle{steps,tup{aux,x}}, count}
  if (steps % 2) set{x, aux, n}
}

def radix_grade_inplace{x:pT, xa:pT, g:pI, ga:pI, n:U, count:pC} = {
  def steps = getsteps{x}
  def c{...p, s} = cycle{steps, p}
  def dsts = flip{tup{
    shiftleft{c{x,xa}, 'sink'}, # Start at xa; ignore last
    reverse  {c{g,ga}}          # End at g
  }}
  radix_main{tup{x,scaltype{pI}~~0}, n, dsts, count}
}

# Radix sorting works even for a count one larger than the type maximum:
# the count array can overflow, but after taking an exclusive sum it
# only affects portions after the last element (that is, target indices
# can't overflow)
def radix_fits{n, T & isint{T} & ~issigned{T}} = n <= 1<<width{T}

# Radix sort on arbitrary types
def radix{x:pT, n:U, aux0} = {
  def T = eltype{pT}; def aux = *T~~aux0
  count := aux+n
  def rad{C} = radix_inplace{x, n, aux, *C~~count}
  index_options{rad, n, radix_fits, tup{u8, u32}}
}

# Sort 32-bit data with a 16-bit range
# In place except the counts in aux
radpack32(x32:*u32, n:u32, aux:*void, min:u32) : void = {
  x16 := *u16 ~~ x32
  aux := x16 + n
  @for (x16, x32 over n) x16 = u16<~(x32 - min)
  def rad{C} = radix_inplace{x16, n, aux, *C~~aux}
  index_options{rad, n, radix_fits, tup{u8, u32}}
  i:u32=n; while (i>0) { --i; x32 <-{i} min + u32^~(x16->i) }
}
