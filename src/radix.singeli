# Fix the radix at 1 byte because other widths take too much computation
def radix_bits = 8
def count_len  = 1<<radix_bits

# Number of steps required
def getsteps{T} = width{T} / radix_bits
def getsteps{P & 'pointer'===typekind{P}} = getsteps{eltype{P}}

# Given a tuple, get corresponding key generators: bytes starting from
# the bottom
def keyfns{tup} = {
  def kf{i} = {
    def sh = i * radix_bits
    {v} => u8<~(v>>sh)
  }
  each{kf, range{tuplen{tup}}}
}

# Sort the n values in x with a number of radix passes equal to steps
# Store counts in count, which must hold steps*count_len counts
# The result for step i is stored at tupsel{i,dsts}
def radix_main{src:pT, n:U, dsts, count:pC} = {
  def steps = tuplen{dsts}
  # Tuple of zeroed count arrays
  def counts = init_counts{count, steps}
  # Count frequency of all bytes simultaneously
  radix_counts{src, n, counts}
  # Exclusive sum of each count array (interleaved for speed)
  prefix_sum_excl{counts, issigned{eltype{pT}}}
  # And do the radix sorting
  radix_move{src, dsts, n, counts}
}

# Zero and split into num arrays with count_len values each
def init_counts{space:pT, num} = {
  fill{space, num*count_len, 0}
  def split{c,n} = merge{c, split{c+count_len, n-1}}
  def split{c,n==0} = tup{}
  split{space, num}
}

# Perform all counts in a single pass
def radix_counts{x, n, counts} = {
  def keys = keyfns{counts}
  @for (x over i to n) {
    def incr{c, k} = incrp{c + k{x}}
    each{incr, counts, keys}
  }
}

# Move data through the successive dsts based on keys and counts
def radix_move{src, dsts, n, counts} = {
  def step{src, dst, count, key} = {
    @for (src over i to n) {
      def k = key{src}
      c := count->k
      dst <-{c} src
      count <-{k} c+1
    }
  }
  def srcs = merge{tup{src}, each{{i}=>tupsel{i,dsts}, range{tuplen{dsts}-1}}}
  each{step, srcs, dsts, counts, keyfns{counts}}
}

# Swap back and forth with aux, ending with the elements in x again
def radix_inplace{x:pT, n:U, aux:pT, count:pC, steps} = {
  def alt{n,t,i,j} = {
    if (i==n) tup{}
    else merge{tupsel{j,t}, alt{n,t,i+1,(j+1)*(j+1<tuplen{t})}}
  }
  radix_main{x, n, alt{steps,tup{aux,x},0,0}, count}
}
def radix_inplace{x:pT, n:U, aux:pT, count:pC} = {
  radix_inplace{x, n, aux, count, getsteps{pT}}
}

# Radix sort on arbitrary types
radix{U, T}(x:*T, n:U, aux:*T) : void = {
  count := aux+n
  def rad{C} = radix_inplace{x, n, aux, *C~~count}
  index_options{rad, n, tup{u8, u32}}
}

# Sort 32-bit data with a 16-bit range
# In place except the counts in aux
radpack32(x32:*u32, n:u32, aux:*void, min:u32) : void = {
  x16 := *u16 ~~ x32
  aux := x16 + n
  @for (x16, x32 over i to n) x16 = u16<~(x32 - min)
  def rad{C} = radix_inplace{x16, n, aux, *C~~aux}
  index_options{rad, n, tup{u8, u32}}
  @for (x32, x16 over i to n) x32 = min + u32^~x16
}
