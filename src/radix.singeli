# LSD Radix sort (includes bucket sort as the 1-step case)
# Sorts the array according to the least significant byte, then the
# next higher, and so on.
# It has the best "generic" performance of any algorithm here, but has
# no adaptivity and in fact slows down on some fairly common patterns
# due to cache associativity. So while the implementation here is
# general, only the 1- and 2-byte forms are used for hybrid sorting.

# Fix the radix at 1 byte because other widths take too much computation
def radix_bits = 8
def count_len  = 1<<radix_bits

# Number of steps required
def getsteps{T} = width{T} / radix_bits
def getsteps{P & tptr{P}} = getsteps{eltype{P}}

# Given a tuple, get corresponding key generators: bytes starting from
# the bottom
def keyfns{tup} = {
  def kf{sh} = ({v} => u8<~(v>>sh))
  each{kf, inds{tup} * radix_bits}
}

# Sort the n values in x with a number of radix passes equal to steps
# Store counts in count, which must hold steps*count_len counts
# The result for step i is stored at tupsel{i,dsts}
def radix_main{src:pT, n:U, dsts, count:pC} = {
  def steps = tuplen{dsts}
  # Tuple of zeroed count arrays
  def counts = init_counts{count, steps}
  # Count frequency of all bytes simultaneously
  radix_counts{src, n, counts}
  # Exclusive sum of each count array (interleaved for speed)
  prefix_sum_excl{counts, issigned{eltype{pT}}}
  # And do the radix sorting
  radix_move{src, dsts, n, counts}
}

# Zero and split into num arrays with count_len values each
def init_counts{space:pT, num} = {
  set{space, 0, num*count_len}
  scan{+, merge{space, copy{num-1, count_len}}}
}

# Perform all counts in a single pass
def radix_counts{x, n, counts} = {
  def keys = keyfns{counts}
  @for (x over n) {
    def incr{c, k} = incrp{c + k{x}}
    each{incr, counts, keys}
  }
}

# Move data through the successive dsts based on keys and counts
def radix_move{src, dsts, n, counts} = {
  def step{src, dst, count, key} = {
    @for (src over n) {
      def k = key{src}
      c := count->k
      dst <-{c} src
      count <-{k} c+1
    }
  }
  def srcs = shiftright{tup{src}, dsts}
  each{step, srcs, dsts, counts, keyfns{counts}}
}

# Swap back and forth with aux, ending with the elements in x again
def radix_inplace{x:pT, n:U, aux:pT, count:pC, steps} = {
  radix_main{x, n, cycle{steps,tup{aux,x}}, count}
  if (steps % 2) set{x, aux, n}
}
def radix_inplace{x:pT, n:U, aux:pT, count:pC} = {
  radix_inplace{x, n, aux, count, getsteps{pT}}
}

# Radix sorting works even for a count one larger than the type maximum:
# the count array can overflow, but after taking an exclusive sum it
# only affects portions after the last element (that is, target indices
# can't overflow)
def radix_fits{n, T & isint{T} & ~issigned{T}} = n <= 1<<width{T}

# Radix sort on arbitrary types
def radix{x:pT, n:U, aux0} = {
  def T = eltype{pT}; def aux = *T~~aux0
  count := aux+n
  def rad{C} = radix_inplace{x, n, aux, *C~~count}
  index_options{rad, n, radix_fits, tup{u8, u32}}
}

# Sort 32-bit data with a 16-bit range
# In place except the counts in aux
radpack32(x32:*u32, n:u32, aux:*void, min:u32) : void = {
  x16 := *u16 ~~ x32
  aux := x16 + n
  @for (x16, x32 over n) x16 = u16<~(x32 - min)
  def rad{C} = radix_inplace{x16, n, aux, *C~~aux}
  index_options{rad, n, radix_fits, tup{u8, u32}}
  i:u32=n; while (i>0) { --i; x32 <-{i} min + u32^~(x16->i) }
}
