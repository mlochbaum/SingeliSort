include './partition'
include './median'
include './xorshift'
include './arith'  # Logs and square roots

def get_pivot{array:pT, n:U, getaux, sort, proc_pivots} = {
  # log_2 of minimum size for sampling
  def sl0 = 14
  # Output array and index
  arr:=array; ind:U = 0
  if (n <= 256) {
    ind = locate_3_median{array, n}
  } else if (n <= 1024) {
    ind = locate_3of3_pseudomedian{array, n}
  } else if (n <= 1 << sl0) {
    ind = locate_5of3_pseudomedian{array, n}
  } else {
    aux := getaux{}
    # gap is the expected distance between adjacent samples
    # We'll get about n/gap samples
    log2:U = floor_log2{n, sl0}
    gap_min := 1 << (log2 / 2 + floor_log2{2 + sl0} >> 1)
    gap := sqrt_approx{2*n * (2+log2), gap_min}

    # Collect samples with split xorshift and add to aux
    aux1 := aux
    def add{ind} = { aux1 <- array->ind; ++aux1 }
    mask := gap_min - 1
    def add3 = make_split_xorshift{tup{13,17,5}, n, mask, add}

    i:U = 0; while (i < n - (mask + 2 * gap)) add3{i, gap}
    ns := aux1 - aux
    sort{aux, ns, *void~~aux1, ns*(width{eltype{pT}}/8)}
    proc_pivots{aux, ns}
    arr = aux
    ind = ns / 2
  }
  arr -> ind
}

# Quicksort loop with unstable partitioning
# Pointer layout credit to Scandum: https://github.com/scandum/fluxsort
# Sort src, placing the result in dst and using space from aux
# src may be equal to dst or aux
def flux_loop{recur, tailcall, piv:T, src:*T, dst:*T, aux:*T, n:U, aux_bytes:U, min:T, rh_approved:u1} = {

  # Partition: left side directly in dst with length l, includes pivots
  l := flux_partition{src, <=, piv, dst, aux, n}

  # Right-hand side
  # If pivot is the maximum value, everything ends in dst
  if (l == n) {
    # Partition again with pivots on the right
    # This bounds performance by O(k*n) for only k unique values
    l = flux_partition{dst, <, piv, dst, aux, n}
    set{dst+l, aux, n-l} # Should probably write a reverse partition to avoid this
  } else {
    # Otherwise, sort the right-hand side, moving it from aux to dst
    recur{aux, dst+l, aux, n-l, aux_bytes, piv, rh_approved}
  }

  # Left-hand side
  if (tailcall) { # Another call on the original arguments follows
    src = dst
    n = l
  } else {
    recur{dst, dst, aux, l, aux_bytes, min, 1, rh_approved}
  }
}

flux32loop{}(src:*i32, dst:*i32, aux:*i32, n:u64, aux_bytes:u64, min:i32, rh_approved:u1) : void = {
  while (u1~~1) {
    # Base case
    if (n < 32) {
      sort_lt32{dst, src, n}
      return{}
    }

    # Distribution base cases
    range := u32 ~~ (dst->n - min)
    if (u64^~(range/4) < n and u64^~range < aux_bytes/(width{u64}/8)) {
      # Always sort in place on dst
      # Counting sort could have a different src/dst, but if src isn't
      # dst then it's equal to aux, and we need that space
      if (src != dst) set{dst, src, n}
      count_sort{dst, u32<~n, *u32~~aux, min, range + 1}
      return{}
    }
    if (n <= (1<<16) and range < (1<<16)) {
      radpack32(*u32~~src, *u32~~dst, u32<~n, *void~~aux, u32~~min)
      return{}
    }
    if (rh_approved) try_rh{src, dst, n, aux, aux_bytes, min, dst->n, merge_chk, merge_from{merge_chk}}

    def getaux{} = { a:=aux; if (a==src) a=dst; a }
    def proc_pivots{pivots, num} = {
      if (n<=1<<16 and not rh_approved) {
        rh_approved = checkdist{pivots, num, min, n, u64^~u32~~(dst->n - min)}
      }
    }
    piv := get_pivot{src, n, getaux, bind{call,flux32}, proc_pivots}
    flux_loop{bind{call,flux32loop{}},1, piv, src,dst,aux,n,aux_bytes, min,rh_approved}
  }
}

flux32(x:*i32, n:u64, aux:*void, aux_bytes:u64) : void = {
  min := i32 ~~ (-1<<31)
  if (n >= 32) {
    def block = 1024
    min = x->0; max := min
    i:u64 = 0; imax:=i
    do {
      i0 := i
      i += block; if (i > n) i = n
      blm := x->i0
      @for (x over j from i0 to i) {
        if (x < min) min=x
        if (x > blm) blm=x
      }
      if (blm > max) { max=blm; imax=i0; }
    } while (i < n)

    if (min == max) return{}
    # TODO unstable
    while (x->imax < max) ++imax
    x <-{imax} x->(n-1)
    x <-{n-1} max
  }

  flux32loop{}(x, x, *i32~~aux, n-1, aux_bytes, min, 0)
}
