def incrp{p} = p <- p->0 + 1
def widen{v} = promote{width{*void}, v}

def do_count{val:*T, len:U, count:*U, min:T, zero} = {
  c := count - widen{min}
  @for (val over i to len) {
    incrp{c + widen{val}}
    if (zero) val=0
  }
}

def count_fill{x, n, count, min, range} = {
  # Count the values
  do_count{x, n, count, min, 0}
  # Write based on the counts
  dst := x; v := min
  @for (count over i to range) {
    set{dst, v, count}; dst += count; ++v
  }
}

def count_sum{x, n, count, min, range} = {
  # Count, and zero, the array
  do_count{x, n, count, min, 1}

  # Write differences to x
  x <-{0} min
  end:=range-1; while (count->end == 0) --end # Assume n>0
  w:=x; @for (count over _ to end) { w+=count; incrp{w} }

  prefix_sum{x, n}
}

# Counting sort of the n values starting at x
def count_sort{x:*T, n:U, aux:*U, min:T, range:U} = {
  set{aux, 0, range}
  if (range < n/8) { # Short range: branching on count is cheap
    count_fill{x, n, aux, min, range}
  } else {
    count_sum{x, n, aux, min, range}
  }
}

# Assume full range
def count_sort{x:pT, n:U, aux} = {
  def T = eltype{pT}
  def range = 1<<width{T}
  def min = { if (issigned{T}) -range/2; else 0 }
  count_sort{x, n, *U~~aux, T~~min, U~~range}
}
