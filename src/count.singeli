def incrp{p} = p <- p->0 + 1
def widen{v} = promote{width{*void}, v}

def do_count{val:*T, len:U, count:*U, min:T, zero} = {
  c := count - widen{min}
  @for (val over len) {
    incrp{c + widen{val}}
    if (zero) val=0
  }
}

def count_fill{x, n, count, min, range} = {
  # Count the values
  do_count{x, n, count, min, 0}
  # Write based on the counts
  dst := x; v := min
  @for (count over range) {
    set{dst, v, count}; dst += count; ++v
  }
}

def count_sum{x, n, count, min:T, range:U} = {
  # Count, and zero, the array
  do_count{x, n, count, min, 1}

  # Write differences to x
  j:U = 0                        # Index in count
  r := undefined{U}              # Running total
  while ((r=count->j) == 0) ++j  # Skip leading 0 counts quickly
  x <- min + T<~j                # First result
  while (r < n) { incrp{x+r}; ++j; r += count->j }

  prefix_sum{x, n}
}

# Counting sort of the n values starting at x
def count_sort{x:*T, n:U, aux:*U, min:T, range:U} = {
  set{aux, 0, range}
  if (range < n/8) { # Short range: branching on count is cheap
    count_fill{x, n, aux, min, range}
  } else {
    count_sum{x, n, aux, min, range}
  }
}

# Assume full range
def count_sort{x:pT, n:U, aux} = {
  def T = eltype{pT}
  def range = 1<<width{T}
  def min = { if (issigned{T}) -range/2; else 0 }
  count_sort{x, n, *U~~aux, T~~min, U~~range}
}
