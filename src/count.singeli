def incrp{p} = p <- p->0 + 1

def do_count{val:*T, len:U, count:*U, min:T, zero} = {
  @for (val over i to len) {
    incrp{count + dist{min,val}}
    if (zero) val=0
  }
}

def count_fill{x, n, count, min, range} = {
  # Count the values
  do_count{x, n, count, min, 0}
  # Write based on the counts
  dst := x; v := min
  @for (count over i to range) {
    fill{dst, count, v}; dst += count; ++v
  }
}

def count_sum{x, n, count, min, range} = {
  # Count, and zero, the array
  do_count{x, n, count, min, 1}

  # Write differences to x
  x <-{0} min
  end:=range-1; while (count->end == 0) --end # Assume n>0
  w:=x; @for (count over _ to end) { w+=count; incrp{w} }

  prefix_sum{x, n}
}

# Counting sort of the n values starting at x
count_sort{U,T}(x:*T, n:U, aux:*U, min:T, range:U) : void = {
  fill{aux, range, 0}
  if (range < n/8) { # Short range: branching on count is cheap
    count_fill{x, n, aux, min, range}
  } else {
    count_sum{x, n, aux, min, range}
  }
}
